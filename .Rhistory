var <- vars_lamb(points,mslp,U)
vars_lamb(a, mslp)
vars_lamb(a, mslp, U = T)
aaa <- vars_lamb(a, mslp, U = T)
aaa
pp <- inner_join(points, mslp, by = c("lon","lat")) %>%
select(c(.data$label,.data$time,.data$value)) %>%
pivot_wider(names_from = .data$label,values_from = .data$value)
points
inner_join(points, mslp, by = c("lon","lat"))
inner_join(points$`438`, mslp, by = c("lon","lat"))
inner_join(points$`438`, mslp, by = c("lon","lat")) %>%
select(c(.data$label,.data$time,.data$value))
inner_join(points$`438`, mslp, by = c("lon","lat")) %>%
select(c(.data$label,.data$time,.data$value)) %>%
pivot_wider(names_from = .data$label,values_from = .data$value)
plot_lamb_scheme(points$`438`)
points
summary(mslp)
xmin = -177.5
lons = seq(xmin,xmax,2.5)
lats = seq(ymin,ymax,2.5)
grid <- expand.grid(lons, lats)[438,]
# get lamb points to all grid
points <- apply(grid,
MARGIN = 1,
function(x) get_lamb_points(x[1], x[2]))
grid <- expand.grid(lons, lats)[438,]
# get lamb points to all grid
points <- apply(grid,
MARGIN = 1,
function(x) get_lamb_points(x[1], x[2]))
lat_max_required <- max(sapply(points, function(x) max(x[[1]])))
lat_min_required <- min(sapply(points, function(x) min(x[[1]])))
lon_max_required <- max(sapply(points, function(x) max(x[[2]])))
lon_min_required <- min(sapply(points, function(x) min(x[[2]])))
if (max(mslp$lon) <= lon_max_required | min(mslp$lon) >= lon_min_required |
max(mslp$lat) <= lat_max_required | min(mslp$lat) >= lat_min_required)
stop(paste0('the mslp dataset has a smaller extent than required.\n
Your mslp extension (xmin, xmax, ymin, ymax):',
min(mslp$lon),",",
max(mslp$lon),",",
min(mslp$lat),",",
max(mslp$lat)),"\n
The required extension (xmin, xmax, ymin, ymax):",
lon_min_required,",",
lon_max_required,",",
lat_min_required,",",
lat_max_required)
vars <- future_lapply(points, FUN = lamb_clas, mslp = mslp, U = T)
points
grid
grid <- expand.grid(lons, lats)[44,]
grid
grid <- expand.grid(lons, lats)[439,]
grid
grid <- expand.grid(lons, lats)[440,]
grid
grid <- expand.grid(lons, lats)[437,]
grid
grid <- expand.grid(lons, lats)[437,]
# get lamb points to all grid
points <- apply(grid,
MARGIN = 1,
function(x) get_lamb_points(x[1], x[2]))
lat_max_required <- max(sapply(points, function(x) max(x[[1]])))
lat_min_required <- min(sapply(points, function(x) min(x[[1]])))
lon_max_required <- max(sapply(points, function(x) max(x[[2]])))
lon_min_required <- min(sapply(points, function(x) min(x[[2]])))
if (max(mslp$lon) <= lon_max_required | min(mslp$lon) >= lon_min_required |
max(mslp$lat) <= lat_max_required | min(mslp$lat) >= lat_min_required)
stop(paste0('the mslp dataset has a smaller extent than required.\n
Your mslp extension (xmin, xmax, ymin, ymax):',
min(mslp$lon),",",
max(mslp$lon),",",
min(mslp$lat),",",
max(mslp$lat)),"\n
The required extension (xmin, xmax, ymin, ymax):",
lon_min_required,",",
lon_max_required,",",
lat_min_required,",",
lat_max_required)
vars <- future_lapply(points, FUN = lamb_clas, mslp = mslp, U = T)
source("C:/Users/gc/Desktop/synoptReg/R/spatial_lamb_clas.R", echo=TRUE)
lons = seq(xmin,xmax,2.5)
lats = seq(ymin,ymax,2.5)
grid <- expand.grid(lons, lats)[436,]
# get lamb points to all grid
points <- apply(grid,
MARGIN = 1,
function(x) get_lamb_points(x[1], x[2]))
lat_max_required <- max(sapply(points, function(x) max(x[[1]])))
lat_min_required <- min(sapply(points, function(x) min(x[[1]])))
lon_max_required <- max(sapply(points, function(x) max(x[[2]])))
lon_min_required <- min(sapply(points, function(x) min(x[[2]])))
if (max(mslp$lon) <= lon_max_required | min(mslp$lon) >= lon_min_required |
max(mslp$lat) <= lat_max_required | min(mslp$lat) >= lat_min_required)
stop(paste0('the mslp dataset has a smaller extent than required.\n
Your mslp extension (xmin, xmax, ymin, ymax):',
min(mslp$lon),",",
max(mslp$lon),",",
min(mslp$lat),",",
max(mslp$lat)),"\n
The required extension (xmin, xmax, ymin, ymax):",
lon_min_required,",",
lon_max_required,",",
lat_min_required,",",
lat_max_required)
vars <- future_lapply(points, FUN = lamb_clas, mslp = mslp, U = T)
grid <- expand.grid(lons, lats)[435,]
grid
grid <- expand.grid(lons, lats)[435,]
# get lamb points to all grid
points <- apply(grid,
MARGIN = 1,
function(x) get_lamb_points(x[1], x[2]))
lat_max_required <- max(sapply(points, function(x) max(x[[1]])))
lat_min_required <- min(sapply(points, function(x) min(x[[1]])))
lon_max_required <- max(sapply(points, function(x) max(x[[2]])))
lon_min_required <- min(sapply(points, function(x) min(x[[2]])))
if (max(mslp$lon) <= lon_max_required | min(mslp$lon) >= lon_min_required |
max(mslp$lat) <= lat_max_required | min(mslp$lat) >= lat_min_required)
stop(paste0('the mslp dataset has a smaller extent than required.\n
Your mslp extension (xmin, xmax, ymin, ymax):',
min(mslp$lon),",",
max(mslp$lon),",",
min(mslp$lat),",",
max(mslp$lat)),"\n
The required extension (xmin, xmax, ymin, ymax):",
lon_min_required,",",
lon_max_required,",",
lat_min_required,",",
lat_max_required)
vars <- future_lapply(points, FUN = lamb_clas, mslp = mslp, U = T)
grid <- expand.grid(lons, lats)[434,]
# get lamb points to all grid
points <- apply(grid,
MARGIN = 1,
function(x) get_lamb_points(x[1], x[2]))
lat_max_required <- max(sapply(points, function(x) max(x[[1]])))
lat_min_required <- min(sapply(points, function(x) min(x[[1]])))
lon_max_required <- max(sapply(points, function(x) max(x[[2]])))
lon_min_required <- min(sapply(points, function(x) min(x[[2]])))
if (max(mslp$lon) <= lon_max_required | min(mslp$lon) >= lon_min_required |
max(mslp$lat) <= lat_max_required | min(mslp$lat) >= lat_min_required)
stop(paste0('the mslp dataset has a smaller extent than required.\n
Your mslp extension (xmin, xmax, ymin, ymax):',
min(mslp$lon),",",
max(mslp$lon),",",
min(mslp$lat),",",
max(mslp$lat)),"\n
The required extension (xmin, xmax, ymin, ymax):",
lon_min_required,",",
lon_max_required,",",
lat_min_required,",",
lat_max_required)
else{
plan(multisession,workers = 10) ## Run in parallel on local computer
vars <- future_lapply(points, FUN = lamb_clas, mslp = mslp, U = T)
clas <- bind_cols(lon = rep(grid$Var1, each = length(unique(mslp$time))),
lat = rep(grid$Var2, each = length(unique(mslp$time))),
cl = bind_rows(vars))
return(clas)
}
vars <- future_lapply(points, FUN = lamb_clas, mslp = mslp, U = T)
points
grid <- expand.grid(lons, lats)[435,]
grid
# get lamb points to all grid
points <- apply(grid,
MARGIN = 1,
function(x) get_lamb_points(x[1], x[2]))
points
grid <- expand.grid(lons, lats)[436,]
# get lamb points to all grid
points <- apply(grid,
MARGIN = 1,
function(x) get_lamb_points(x[1], x[2]))
points
grid <- expand.grid(lons, lats)[437,]
# get lamb points to all grid
points <- apply(grid,
MARGIN = 1,
function(x) get_lamb_points(x[1], x[2]))
lat_max_required <- max(sapply(points, function(x) max(x[[1]])))
points
grid <- expand.grid(lons, lats)[434,]
# get lamb points to all grid
points <- apply(grid,
MARGIN = 1,
function(x) get_lamb_points(x[1], x[2]))
point
points
which(!-180)
which(!points)
poins
points
purrr::discard(points, ~any(.x$lon == -180))
# get lamb points to all grid
points <- apply(grid,
MARGIN = 1,
function(x) get_lamb_points(x[1], x[2]))
purrr::discard(points, ~any(.x$lon == -180))
grid <- expand.grid(lons, lats)[433,]
# get lamb points to all grid
points <- apply(grid,
MARGIN = 1,
function(x) get_lamb_points(x[1], x[2]))
purrr::discard(points, ~any(.x$lon == -180))
mslp <- metR::ReadNetCDF(file = "data/slp.2010.nc") %>%
rename("value" = "slp") %>%
mutate(lon = metR::ConvertLongitude(lon),
value = value/100)
summary(mslp)
spatial_lamb <- function(mslp, xmin = -180, xmax = 180 , ymin = -80, ymax = 80 ){
lons = seq(xmin,xmax,2.5)
lats = seq(ymin,ymax,2.5)
grid <- expand.grid(lons, lats)
# get lamb points to all grid
points <- apply(grid,
MARGIN = 1,
function(x) get_lamb_points(x[1], x[2]))
# -180 doesn't exist in NCEP NCAR
purrr::discard(points, ~any(.x$lon == -180))
lat_max_required <- max(sapply(points, function(x) max(x[[1]])))
lat_min_required <- min(sapply(points, function(x) min(x[[1]])))
lon_max_required <- max(sapply(points, function(x) max(x[[2]])))
lon_min_required <- min(sapply(points, function(x) min(x[[2]])))
if (max(mslp$lon) <= lon_max_required | min(mslp$lon) >= lon_min_required |
max(mslp$lat) <= lat_max_required | min(mslp$lat) >= lat_min_required)
stop(paste0('the mslp dataset has a smaller extent than required.\n
Your mslp extension (xmin, xmax, ymin, ymax):',
min(mslp$lon),",",
max(mslp$lon),",",
min(mslp$lat),",",
max(mslp$lat)),"\n
The required extension (xmin, xmax, ymin, ymax):",
lon_min_required,",",
lon_max_required,",",
lat_min_required,",",
lat_max_required)
else{
plan(multisession,workers = 10) ## Run in parallel on local computer
vars <- future_lapply(points, FUN = lamb_clas, mslp = mslp, U = T)
clas <- bind_cols(lon = rep(grid$Var1, each = length(unique(mslp$time))),
lat = rep(grid$Var2, each = length(unique(mslp$time))),
cl = bind_rows(vars))
return(clas)
}
}
xmin = -180
xmax = 180
lons = seq(xmin,xmax,2.5)
lats = seq(ymin,ymax,2.5)
grid <- expand.grid(lons, lats)
# get lamb points to all grid
points <- apply(grid,
MARGIN = 1,
function(x) get_lamb_points(x[1], x[2]))
points <- purrr::discard(points, ~any(.x$lon == -180))
points
lat_max_required <- max(sapply(points, function(x) max(x[[1]])))
lat_min_required <- min(sapply(points, function(x) min(x[[1]])))
lon_max_required <- max(sapply(points, function(x) max(x[[2]])))
lon_min_required <- min(sapply(points, function(x) min(x[[2]])))
if (max(mslp$lon) <= lon_max_required | min(mslp$lon) >= lon_min_required |
max(mslp$lat) <= lat_max_required | min(mslp$lat) >= lat_min_required)
stop(paste0('the mslp dataset has a smaller extent than required.\n
Your mslp extension (xmin, xmax, ymin, ymax):',
min(mslp$lon),",",
max(mslp$lon),",",
min(mslp$lat),",",
max(mslp$lat)),"\n
The required extension (xmin, xmax, ymin, ymax):",
lon_min_required,",",
lon_max_required,",",
lat_min_required,",",
lat_max_required)
if (max(mslp$lon) < lon_max_required | min(mslp$lon) > lon_min_required |
max(mslp$lat) < lat_max_required | min(mslp$lat) > lat_min_required)
stop(paste0('the mslp dataset has a smaller extent than required.\n
Your mslp extension (xmin, xmax, ymin, ymax):',
min(mslp$lon),",",
max(mslp$lon),",",
min(mslp$lat),",",
max(mslp$lat)),"\n
The required extension (xmin, xmax, ymin, ymax):",
lon_min_required,",",
lon_max_required,",",
lat_min_required,",",
lat_max_required)
plan(multisession,workers = 10) ## Run in parallel on local computer
vars <- future_lapply(points, FUN = lamb_clas, mslp = mslp, U = T)
clas <- bind_cols(lon = rep(grid$Var1, each = length(unique(mslp$time))),
lat = rep(grid$Var2, each = length(unique(mslp$time))),
cl = bind_rows(vars))
bind_cols(lon = rep(grid$Var1, each = length(unique(mslp$time))),
lat = rep(grid$Var2, each = length(unique(mslp$time))))
clas <- bind_cols(lon = rep(grid$Var1, each = length(unique(mslp$time))),
lat = rep(grid$Var2, each = length(unique(mslp$time))),
cl = bind_rows(vars))
grid
class(grid)
filter(grid, var1 !=-180)
filter(grid, Var1 !=-180)
grid2 <- filter(grid, Var1 !=-180)
vars <- future_lapply(points, FUN = lamb_clas, mslp = mslp, U = T)
clas <- bind_cols(lon = rep(grid2$Var1, each = length(unique(mslp$time))),
lat = rep(grid2$Var2, each = length(unique(mslp$time))),
cl = bind_rows(vars))
(vars)
lon = rep(grid2$Var1, each = length(unique(mslp$time)))
lon
bind_cols(lon = rep(grid2$Var1, each = length(unique(mslp$time))),
lat = rep(grid2$Var2, each = length(unique(mslp$time)))
)
bind_rows(vars)
grid <- expand.grid(lons, lats) %>%
filter(Var1 !=-180)
grid
# get lamb points to all grid
points <- apply(grid,
MARGIN = 1,
function(x) get_lamb_points(x[1], x[2]))
points <- purrr::discard(points, ~any(.x$lon == -180))
lat_max_required <- max(sapply(points, function(x) max(x[[1]])))
lat_min_required <- min(sapply(points, function(x) min(x[[1]])))
lon_max_required <- max(sapply(points, function(x) max(x[[2]])))
lon_min_required <- min(sapply(points, function(x) min(x[[2]])))
if (max(mslp$lon) < lon_max_required | min(mslp$lon) > lon_min_required |
max(mslp$lat) < lat_max_required | min(mslp$lat) > lat_min_required)
stop(paste0('the mslp dataset has a smaller extent than required.\n
Your mslp extension (xmin, xmax, ymin, ymax):',
min(mslp$lon),",",
max(mslp$lon),",",
min(mslp$lat),",",
max(mslp$lat)),"\n
The required extension (xmin, xmax, ymin, ymax):",
lon_min_required,",",
lon_max_required,",",
lat_min_required,",",
lat_max_required)
plan(multisession,workers = 10) ## Run in parallel on local computer
vars <- future_lapply(points, FUN = lamb_clas, mslp = mslp, U = T)
clas <- bind_cols(lon = rep(grid$Var1, each = length(unique(mslp$time))),
lat = rep(grid$Var2, each = length(unique(mslp$time))),
cl = bind_rows(vars))
vars
bind_cols(lon = rep(grid$Var1, each = length(unique(mslp$time))),
lat = rep(grid$Var2, each = length(unique(mslp$time))))
expand.grid(lons, lats)
expand.grid(lons, lats) %>%
filter(Var1 !=-180)
grid <- expand.grid(lons, lats) %>%
filter(Var1 !=-180)
# get lamb points to all grid
points <- apply(grid,
MARGIN = 1,
function(x) get_lamb_points(x[1], x[2]))
points <- purrr::discard(points, ~any(.x$lon == -180))
# get lamb points to all grid
points <- apply(grid,
MARGIN = 1,
function(x) get_lamb_points(x[1], x[2]))
clas <- bind_cols(lon = rep(grid$Var1, each = length(unique(mslp$time))),
lat = rep(grid$Var2, each = length(unique(mslp$time))),
cl = bind_rows(vars))
grid <- expand.grid(lons, lats) %>%
filter(Var1 !=-180)
points <- purrr::discard(points, ~any(.x$lon == -180))
grid
# get lamb points to all grid
points <- apply(grid,
MARGIN = 1,
function(x) get_lamb_points(x[1], x[2]))
lat_max_required <- max(sapply(points, function(x) max(x[[1]])))
lat_min_required <- min(sapply(points, function(x) min(x[[1]])))
lon_max_required <- max(sapply(points, function(x) max(x[[2]])))
lon_min_required <- min(sapply(points, function(x) min(x[[2]])))
if (max(mslp$lon) < lon_max_required | min(mslp$lon) > lon_min_required |
max(mslp$lat) < lat_max_required | min(mslp$lat) > lat_min_required)
stop(paste0('the mslp dataset has a smaller extent than required.\n
Your mslp extension (xmin, xmax, ymin, ymax):',
min(mslp$lon),",",
max(mslp$lon),",",
min(mslp$lat),",",
max(mslp$lat)),"\n
The required extension (xmin, xmax, ymin, ymax):",
lon_min_required,",",
lon_max_required,",",
lat_min_required,",",
lat_max_required)
plan(multisession,workers = 10) ## Run in parallel on local computer
vars <- future_lapply(points, FUN = lamb_clas, mslp = mslp, U = T)
points <- purrr::discard(points, ~any(.x$lon == -180))
grid
lons[lons != -180]
lons = lons[lons != -180]
lats = seq(ymin,ymax,2.5)
expand.grid(lons, lats)
grid <- expand.grid(lons, lats) %>%
filter(Var1 !=-180)
lons = seq(xmin,xmax,2.5)
lats = seq(ymin,ymax,2.5)
grid <- expand.grid(lons, lats) %>%
filter(Var1 !=-180)
# get lamb points to all grid
points <- apply(grid,
MARGIN = 1,
function(x) get_lamb_points(x[1], x[2]))
points
grid <- purrr::discard(grid, ~any(.x$Var1 == -180))
grid
grid <- expand.grid(lons, lats)
grid <- purrr::discard(grid, ~any(.x$Var1 == -180))
get_lamb_points <- function(x,y) {
xi <- 10
yi <- 5
gp_y <- y - seq(-10,10,by= 5)
gp_x <- x - c(-15,-5,5,15)
gp_x <- ifelse(gp_x < -177.5, gp_x +360,gp_x)
gp_x <- ifelse(gp_x > 180, gp_x -360,gp_x)
pre_scheme <- expand.grid(gp_y,gp_x) %>%
setNames(c("y","x"))
corners <- subset(pre_scheme, x == min(x) & y == min(y)|
x == min(x) & y == max(y)|
x == max(x) & y == min(y)|
x == max(x) & y == max(y))
jc_scheme <- cbind.data.frame(pre_scheme,
TF = interaction(pre_scheme) %in% interaction(corners)) %>%
filter(.data$TF == F) %>%
select(-.data$TF) %>%
cbind.data.frame(c("P6","P10","P14",
"P2","P5","P9","P13","P16",
"P1","P4","P8","P12","P15",
"P3","P7","P11")) %>%
setNames(c("lat","lon","label"))
return(jc_scheme)
}
lons = seq(xmin,xmax,2.5)
lats = seq(ymin,ymax,2.5)
grid <- expand.grid(lons, lats) %>%
filter(Var1 !=-180)
# get lamb points to all grid
points <- apply(grid,
MARGIN = 1,
function(x) get_lamb_points(x[1], x[2]))
points <- purrr::discard(points, ~any(.x$lon == -180))
lat_max_required <- max(sapply(points, function(x) max(x[[1]])))
lat_min_required <- min(sapply(points, function(x) min(x[[1]])))
lon_max_required <- max(sapply(points, function(x) max(x[[2]])))
lon_min_required <- min(sapply(points, function(x) min(x[[2]])))
if (max(mslp$lon) < lon_max_required | min(mslp$lon) > lon_min_required |
max(mslp$lat) < lat_max_required | min(mslp$lat) > lat_min_required)
stop(paste0('the mslp dataset has a smaller extent than required.\n
Your mslp extension (xmin, xmax, ymin, ymax):',
min(mslp$lon),",",
max(mslp$lon),",",
min(mslp$lat),",",
max(mslp$lat)),"\n
The required extension (xmin, xmax, ymin, ymax):",
lon_min_required,",",
lon_max_required,",",
lat_min_required,",",
lat_max_required)
vars <- future_lapply(points, FUN = lamb_clas, mslp = mslp, U = T)
plan(multisession,workers = 10) ## Run in parallel on local computer
vars <- future_lapply(points, FUN = lamb_clas, mslp = mslp, U = T)
clas <- bind_cols(lon = rep(grid$Var1, each = length(unique(mslp$time))),
lat = rep(grid$Var2, each = length(unique(mslp$time))),
cl = bind_rows(vars))
clas$WT <- as.factor(clas$WT)
clas$WT <- factor(clas$WT, levels = c("A","ANE","AE","ASE","AS","ASW","AW","ANW","AN",
"NE","E","SE","S","SW","W","NW","N",
"C","CNE","CE","CSE","CS","CSW","CW","CNW","CN",
"U"))
paleta <- c("#F24530","#ED622F","#E97F2F","#E59B2E","#E1B92D","#E3BF35","#E5C53F","#E8CB47","#EBD251",
"#B1DBAD","#A0D29D","#8DC88D","#79BE80","#50A567","#42965C","#338750","#237943",
"#1C3C6B","#204C82","#255E99","#306CA6","#3C7BB2","#4989BB","#5797C3","#67A4CA","#78B0D2",
"#737373")
world <- rnaturalearth::ne_countries(returnclass = "sp")
ggplot()+
geom_tile(data = filter(clas, time == as.Date("2010-07-01")),
aes(lon,lat, fill= WT), color = "white", size = 0.1)+
geom_path(data = world,aes(long,lat, group = group),
fill = "transparent", color = "black", size = 0.4) +
scale_x_continuous(limits = c(-170,170),expand = c(0,0))+
scale_y_continuous(limits = c(-80,80),expand = c(0,0))+
scale_fill_manual(values = paleta)+
guides(fill=guide_legend(nrow =1, label.position = "bottom"))+
coord_map(projection = "mollweide")+
theme_void() +
theme(legend.position = "bottom",
legend.spacing.x = unit(0, 'cm'),
legend.title = element_blank(),
legend.key = element_rect(color = "black"))
ggsave("test.png", height = 20, width = 22,units = "cm",dpi = 600)
ggplot()+
geom_tile(data = filter(clas, lat > 15, lat< -15, time == as.Date("2010-07-01")),
aes(lon,lat, fill= WT), color = "white", size = 0.1)+
geom_path(data = world,aes(long,lat, group = group),
fill = "transparent", color = "black", size = 0.4) +
scale_x_continuous(limits = c(-170,170),expand = c(0,0))+
scale_y_continuous(limits = c(-80,80),expand = c(0,0))+
scale_fill_manual(values = paleta)+
guides(fill=guide_legend(nrow =1, label.position = "bottom"))+
coord_map(projection = "mollweide")+
theme_void() +
theme(legend.position = "bottom",
legend.spacing.x = unit(0, 'cm'),
legend.title = element_blank(),
legend.key = element_rect(color = "black"))
