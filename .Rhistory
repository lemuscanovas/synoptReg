# Ensure input is a SpatRaster
if(!is(x, "SpatRaster")) {
stop("Input should be a SpatRaster object")
}
pca <- prcomp(na.omit(spatSample(x,ncell(x),"regular")))
eigs <- pca$sdev^2
info_variance <- rbind(
SD = sqrt(eigs),
Proportion = eigs/sum(eigs),
Cumulative = cumsum(eigs)/sum(eigs))
pca_predict <- predict(x, pca)
names(pca_predict) <- paste0("PC", 1:nlyr(pca_predict))
if(!is.null(aggr)){
pca_predict <- aggregate(pca_predict,aggr)
}
if(!is.null(focal)){
pca_predict <- focal(pca_predict, w=focal, fun="mean")
}
return(pca_predict)
}
}
}
computePCA <- function(x, aggr = NULL, focal = NULL) {
computePCA <- function(x, aggr = NULL, focal = NULL) {
# Ensure input is a SpatRaster
if(!is(x, "SpatRaster")) {
stop("Input should be a SpatRaster object")
}
}
}
}
computePCA <- function(x, aggr = NULL, focal = NULL){
# Ensure input is a SpatRaster
if(!is(x, "SpatRaster")) {
stop("Input should be a SpatRaster object")
}
pca <- prcomp(na.omit(spatSample(x,ncell(x),"regular")))
eigs <- pca$sdev^2
info_variance <- rbind(
SD = sqrt(eigs),
Proportion = eigs/sum(eigs),
Cumulative = cumsum(eigs)/sum(eigs))
pca_predict <- predict(x, pca)
names(pca_predict) <- paste0("PC", 1:nlyr(pca_predict))
if(!is.null(aggr)){
pca_predict <- aggregate(pca_predict,aggr)
}
if(!is.null(focal)){
pca_predict <- focal(pca_predict, w=focal, fun="mean")
}
return(list("PCA" = pca_predict,
"summaryPCA" = info_variance))
}
computePCA <- function(x, aggr = NULL, focal = NULL){
}
}
x
raster_pca <- function(x, aggr = NULL, focal = NULL){
raster_pca <- function(x, aggr = NULL, focal = NULL){
# Ensure input is a SpatRaster
if(!is(x, "SpatRaster")) {
stop("Input should be a SpatRaster object")
}
pca <- prcomp(na.omit(spatSample(x,ncell(x),"regular")))
eigs <- pca$sdev^2
info_variance <- rbind(
SD = sqrt(eigs),
Proportion = eigs/sum(eigs),
Cumulative = cumsum(eigs)/sum(eigs))
pca_predict <- predict(x, pca)
names(pca_predict) <- paste0("PC", 1:nlyr(pca_predict))
if(!is.null(aggr)){
pca_predict <- aggregate(pca_predict,aggr)
}
if(!is.null(focal)){
pca_predict <- focal(pca_predict, w=focal, fun="mean")
}
return(list("PCA" = pca_predict,
"summaryPCA" = info_variance))
}
raster_pca(env)
raster_pca(env)$PCA
pca_result <- raster_pca(env)$PCA
regionalization <- function(x, centers, iter.max = 100, nstart = 100, algorithm = "Lloyd") {
rasters <- x
nr <- as.data.frame(rasters, cell=TRUE)
# K-means computation
set.seed(99)
kmncluster <- kmeans(nr[,-1], centers=centers,
iter.max = iter.max,
nstart = nstart,
algorithm = algorithm)
knr <- rast(rasters, nlyr=1)
knr[nr$cell] <- kmncluster$cluster
return(list("cluster_info"=kmncluster,
"cluster_rast"=knr))
}
regionalization(pca_result)
regionalization(pca_result,centers = 3)
regionalization(pca_result,centers = 3)$cluster_rast
regionalization(pca_result,centers = 3)$cluster_rast %>% plot
data(z500)
summary(z500)
data(pcp)
data(msl)
summary(msl)
som_clas <- function(x, xdim, ydim,iter = 2000, alpha = c(0.05,0.01),
dist.fcts = "euclidean", mode = "online",
cores = 1, norm = T) {
dataset <- x %>%
select(-units) %>%
group_by(.data$var, .data$x, .data$y) %>%
mutate(value = scale(.data$value)) %>%
unite("varxy",var:y, sep = "_") %>%
tidyr::pivot_wider(names_from = .data$varxy, values_from= .data$value)
# Transforming into a matrix
matrix_vars <- dataset %>% dplyr::ungroup() %>%
dplyr::select(-.data$time) %>% as.matrix()
# Creating a SOM network
WTs = xdim*ydim
som_vars <- som(X = matrix_vars,
grid = somgrid(xdim = xdim,
ydim = ydim,
neighbourhood.fct = "gaussian",
topo = "rectangular"),
rlen = iter,
alpha = alpha,
keep.data = T,
dist.fcts = dist.fcts,
mode = mode,
cores = cores)
grid_som_vars <- som_vars$codes[[1]] %>%
as.data.frame() %>% as_tibble() %>%
mutate(xdim = rep(1:xdim,xdim),
ydim = rep(1:ydim, each = ydim),
WT = 1:WTs) %>%
relocate(.data$ydim, .before = 1) %>%
relocate(.data$xdim, .before = .data$ydim) %>%
relocate(.data$WT, .before = .data$xdim) %>%
pivot_longer(4:ncol(.),names_to = "grid") %>%
separate(col = .data$grid, into = c("var","x","y"),sep = "_") %>%
mutate_at(.vars = vars(.data$x,.data$y), .funs = as.numeric) %>%
select(.data$var,.data$x,.data$y,.data$WT, .data$xdim, .data$ydim)
clas <- tibble(time = unique(x$time), WT = som_vars$unit.classif)
df_classified <- x %>%
inner_join(clas, by = "time") %>%
inner_join(grid_som_vars, by = c("var","x","y","WT"))
df_classified_panels <- df_classified %>%
group_by(.data$x, .data$y, .data$WT, .data$var) %>%
mutate(mean_WT_value = mean(.data$value),
# pval_ttest = t.test(.data$anom_value, mu = 0)$p.value,
cv_WT_value = (sd(.data$value) / mean(.data$value)) * 100) %>%
select(-.data$value) %>%
ungroup() %>%
distinct(.data$x, .data$y, .data$WT, .data$var, .keep_all = T)
return(list(clas = clas,
grid_clas = df_classified_panels,
som_info = som_vars))
}
som_cl <- som_clas(z500, xdim = 4, ydim = 4, iter = 200)
dataset <- x %>%
select(-units) %>%
group_by(.data$var, .data$x, .data$y) %>%
mutate(value = scale(.data$value)) %>%
unite("varxy",var:y, sep = "_") %>%
tidyr::pivot_wider(names_from = .data$varxy, values_from= .data$value)
x = z500
dataset <- x %>%
select(-units) %>%
group_by(.data$var, .data$x, .data$y) %>%
mutate(value = scale(.data$value)) %>%
unite("varxy",var:y, sep = "_") %>%
tidyr::pivot_wider(names_from = .data$varxy, values_from= .data$value)
x %>%
select(-units)
x %>%
select(-units) %>%
group_by(.data$var, .data$x, .data$y)
x %>%
select(-units) %>%
group_by(.data$var, .data$x, .data$y) %>%
mutate(value = scale(.data$value))
x %>%
select(-units) %>%
group_by(.data$var, .data$x, .data$y) %>%
mutate(value = scale(.data$value)) %>%
unite("varxy",var:y, sep = "_")
x %>%
select(-units) %>%
group_by(.data$var, .data$x, .data$y) %>%
mutate(value = scale(.data$value))
x %>%
select(-units) %>%
group_by(.data$var, .data$x, .data$y) %>%
mutate(value = scale(.data$value)) %>%
unite("varxy",c(var,x,y), sep = "_") %>%
tidyr::pivot_wider(names_from = .data$varxy, values_from= .data$value)
dataset <- x %>%
select(-units) %>%
group_by(.data$var, .data$x, .data$y) %>%
mutate(value = scale(.data$value)) %>%
unite("varxy",c(var,x,y), sep = "_") %>%
tidyr::pivot_wider(names_from = .data$varxy, values_from= .data$value)
# Transforming into a matrix
matrix_vars <- dataset %>% dplyr::ungroup() %>%
dplyr::select(-.data$time) %>% as.matrix()
WTs = xdim*ydim
som_vars <- som(X = matrix_vars,
grid = somgrid(xdim = xdim,
ydim = ydim,
neighbourhood.fct = "gaussian",
topo = "rectangular"),
rlen = iter,
alpha = alpha,
keep.data = T,
dist.fcts = dist.fcts,
mode = mode,
cores = cores)
grid_som_vars <- som_vars$codes[[1]] %>%
as.data.frame() %>% as_tibble() %>%
mutate(xdim = rep(1:xdim,xdim),
ydim = rep(1:ydim, each = ydim),
WT = 1:WTs) %>%
relocate(.data$ydim, .before = 1) %>%
relocate(.data$xdim, .before = .data$ydim) %>%
relocate(.data$WT, .before = .data$xdim) %>%
pivot_longer(4:ncol(.),names_to = "grid") %>%
separate(col = .data$grid, into = c("var","x","y"),sep = "_") %>%
mutate_at(.vars = vars(.data$x,.data$y), .funs = as.numeric) %>%
select(.data$var,.data$x,.data$y,.data$WT, .data$xdim, .data$ydim)
clas <- tibble(time = unique(x$time), WT = som_vars$unit.classif)
df_classified <- x %>%
inner_join(clas, by = "time") %>%
inner_join(grid_som_vars, by = c("var","x","y","WT"))
df_classified <- x %>%
inner_join(clas, by = "time") %>%
inner_join(grid_som_vars, by = c("var","x","y","WT"))
x
x %>%
inner_join(clas, by = "time")
x
clas
clas <- tibble(time = unique(x$time), WT = som_vars$unit.classif)
clas
tibble(time = unique(x$time), WT = som_vars$unit.classif)
unique(x$time)
WT = som_vars$unit.classif
som_vars$unit.classif
som_vars
som_vars <- som(X = matrix_vars,
grid = somgrid(xdim = xdim,
ydim = ydim,
neighbourhood.fct = "gaussian",
topo = "rectangular"),
rlen = iter,
alpha = alpha,
keep.data = T,
dist.fcts = dist.fcts,
mode = mode,
cores = cores)
som_vars
matrix_vars
somgrid
data(z500)
# SOM classification
som_cl <- som_clas(z500, xdim = 4, ydim = 4, iter = 200)
som_clas <- function(x, xdim, ydim,iter = 2000, alpha = c(0.05,0.01),
dist.fcts = "euclidean", mode = "online",
cores = 1, norm = T) {
dataset <- x %>%
select(-units) %>%
group_by(.data$var, .data$x, .data$y) %>%
mutate(value = scale(.data$value)) %>%
unite("varxy",c(var,x,y), sep = "_") %>%
tidyr::pivot_wider(names_from = .data$varxy, values_from= .data$value)
# Transforming into a matrix
matrix_vars <- dataset %>% dplyr::ungroup() %>%
dplyr::select(-.data$time) %>% as.matrix()
# Creating a SOM network
WTs = xdim*ydim
som_vars <- som(X = matrix_vars,
grid = somgrid(xdim = xdim,
ydim = ydim,
neighbourhood.fct = "gaussian",
topo = "rectangular"),
rlen = iter,
alpha = alpha,
keep.data = T,
dist.fcts = dist.fcts,
mode = mode,
cores = cores)
grid_som_vars <- som_vars$codes[[1]] %>%
as.data.frame() %>% as_tibble() %>%
mutate(xdim = rep(1:xdim,xdim),
ydim = rep(1:ydim, each = ydim),
WT = 1:WTs) %>%
relocate(.data$ydim, .before = 1) %>%
relocate(.data$xdim, .before = .data$ydim) %>%
relocate(.data$WT, .before = .data$xdim) %>%
pivot_longer(4:ncol(.),names_to = "grid") %>%
separate(col = .data$grid, into = c("var","x","y"),sep = "_") %>%
mutate_at(.vars = vars(.data$x,.data$y), .funs = as.numeric) %>%
select(.data$var,.data$x,.data$y,.data$WT, .data$xdim, .data$ydim)
clas <- tibble(time = unique(x$time), WT = som_vars$unit.classif)
df_classified <- x %>%
inner_join(clas, by = "time") %>%
inner_join(grid_som_vars, by = c("var","x","y","WT"))
df_classified_panels <- df_classified %>%
group_by(.data$x, .data$y, .data$WT, .data$var) %>%
mutate(mean_WT_value = mean(.data$value),
# pval_ttest = t.test(.data$anom_value, mu = 0)$p.value,
cv_WT_value = (sd(.data$value) / mean(.data$value)) * 100) %>%
select(-.data$value) %>%
ungroup() %>%
distinct(.data$x, .data$y, .data$WT, .data$var, .keep_all = T)
return(list(clas = clas,
grid_clas = df_classified_panels,
som_info = som_vars))
}
som_cl <- som_clas(z500, xdim = 4, ydim = 4, iter = 200)
library(tidyverse)
som_cl <- som_clas(z500, xdim = 4, ydim = 4, iter = 200)
som
library(kohonen)
som_clas <- function(x, xdim, ydim,iter = 2000, alpha = c(0.05,0.01),
dist.fcts = "euclidean", mode = "online",
cores = 1, norm = T) {
dataset <- x %>%
select(-units) %>%
group_by(.data$var, .data$x, .data$y) %>%
mutate(value = scale(.data$value)) %>%
unite("varxy",c(var,x,y), sep = "_") %>%
tidyr::pivot_wider(names_from = .data$varxy, values_from= .data$value)
# Transforming into a matrix
matrix_vars <- dataset %>% dplyr::ungroup() %>%
dplyr::select(-.data$time) %>% as.matrix()
# Creating a SOM network
WTs = xdim*ydim
som_vars <- som(X = matrix_vars,
grid = somgrid(xdim = xdim,
ydim = ydim,
neighbourhood.fct = "gaussian",
topo = "rectangular"),
rlen = iter,
alpha = alpha,
keep.data = T,
dist.fcts = dist.fcts,
mode = mode,
cores = cores)
grid_som_vars <- som_vars$codes[[1]] %>%
as.data.frame() %>% as_tibble() %>%
mutate(xdim = rep(1:xdim,xdim),
ydim = rep(1:ydim, each = ydim),
WT = 1:WTs) %>%
relocate(.data$ydim, .before = 1) %>%
relocate(.data$xdim, .before = .data$ydim) %>%
relocate(.data$WT, .before = .data$xdim) %>%
pivot_longer(4:ncol(.),names_to = "grid") %>%
separate(col = .data$grid, into = c("var","x","y"),sep = "_") %>%
mutate_at(.vars = vars(.data$x,.data$y), .funs = as.numeric) %>%
select(.data$var,.data$x,.data$y,.data$WT, .data$xdim, .data$ydim)
clas <- tibble(time = unique(x$time), WT = som_vars$unit.classif)
df_classified <- x %>%
inner_join(clas, by = "time") %>%
inner_join(grid_som_vars, by = c("var","x","y","WT"))
df_classified_panels <- df_classified %>%
group_by(.data$x, .data$y, .data$WT, .data$var) %>%
mutate(mean_WT_value = mean(.data$value),
# pval_ttest = t.test(.data$anom_value, mu = 0)$p.value,
cv_WT_value = (sd(.data$value) / mean(.data$value)) * 100) %>%
select(-.data$value) %>%
ungroup() %>%
distinct(.data$x, .data$y, .data$WT, .data$var, .keep_all = T)
return(list(clas = clas,
grid_clas = df_classified_panels,
som_info = som_vars))
}
som_cl <- som_clas(z500, xdim = 4, ydim = 4, iter = 200)
som_cl
som_clas <- function(x, xdim, ydim,iter = 2000, alpha = c(0.05,0.01),
dist.fcts = "euclidean", mode = "online",
cores = 1, norm = T) {
dataset <- x %>%
select(-units) %>%
group_by(.data$var, .data$x, .data$y) %>%
mutate(value = scale(.data$value)) %>%
unite("varxy",c(var,x,y), sep = "_") %>%
tidyr::pivot_wider(names_from = .data$varxy, values_from= .data$value)
# Transforming into a matrix
matrix_vars <- dataset %>% dplyr::ungroup() %>%
dplyr::select(-time) %>% as.matrix()
# Creating a SOM network
WTs = xdim*ydim
som_vars <- som(X = matrix_vars,
grid = somgrid(xdim = xdim,
ydim = ydim,
neighbourhood.fct = "gaussian",
topo = "rectangular"),
rlen = iter,
alpha = alpha,
keep.data = T,
dist.fcts = dist.fcts,
mode = mode,
cores = cores)
grid_som_vars <- som_vars$codes[[1]] %>%
as.data.frame() %>% as_tibble() %>%
mutate(xdim = rep(1:xdim,xdim),
ydim = rep(1:ydim, each = ydim),
WT = 1:WTs) %>%
relocate(.data$ydim, .before = 1) %>%
relocate(.data$xdim, .before = .data$ydim) %>%
relocate(.data$WT, .before = .data$xdim) %>%
pivot_longer(4:ncol(.),names_to = "grid") %>%
separate(col = .data$grid, into = c("var","x","y"),sep = "_") %>%
mutate_at(.vars = vars(.data$x,.data$y), .funs = as.numeric) %>%
select(var,x,y,WT,xdim,ydim)
clas <- tibble(time = unique(x$time), WT = som_vars$unit.classif)
df_classified <- x %>%
inner_join(clas, by = "time") %>%
inner_join(grid_som_vars, by = c("var","x","y","WT"))
df_classified_panels <- df_classified %>%
group_by(.data$x, .data$y, .data$WT, .data$var) %>%
mutate(mean_WT_value = mean(value),
# pval_ttest = t.test(.data$anom_value, mu = 0)$p.value,
cv_WT_value = (sd(value) / mean(value)) * 100) %>%
select(-value) %>%
ungroup() %>%
distinct(x, y, WT, var, .keep_all = T)
return(list(clas = clas,
grid_clas = df_classified_panels,
som_info = som_vars))
}
som_cl <- som_clas(z500, xdim = 4, ydim = 4, iter = 200)
roxygen2::roxygenise()
roxygen2::roxygenise()
as_synoptreg <- function(x){
varname <- varnames(x)
unit <- unique(units(x))
df <- terra::as.data.frame(x, xy = T) %>%
pivot_longer(names_to = "time",values_to = "value", 3:ncol(.)) %>%
mutate(time = as_date(str_remove(time, "X")),
var = varname,
units = unit)
return(df)
}
roxygen2::roxygenise()
roxygen2::roxygenise()
checkCRAN()
devtools::check()
devtools::check()
library(devtools)
find_rtools()
find_rtools()
library(devtools)
install.packages("devtools")
library(devtools)
find_rtools()
devtools::check()
roxygen2::roxygenise()
install.packages("terra")
library(terra)
install.packages("terra")
install.packages("C:/Users/gc/Downloads/terra_1.7-46.zip", repos = NULL, type = "win.binary")
library(terra)
roxygen2::roxygenise()
roxygen2::roxygenise()
devtools::check()
library(ncdf4)
install.packages(c('maptools', 'ncdf4', 'rgeos', 'udunits2', 'gridExtra'))
devtools::check()
devtools::check()
inherits(x = x)
devtools::check()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
devtools::check()
roxygen2::roxygenise()
devtools::check()
roxygen2::roxygenise()
devtools::check()
devtools::check()
roxygen2::roxygenise()
devtools::check()
is.Date()
roxygen2::roxygenise()
devtools::check()
roxygen2::roxygenise()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
